#!/bin/bash

HOOK_FILE=".git/hooks/prepare-commit-msg"
SCRIPT_NAME=$(basename "$0")
MODEL=${MODEL:-qwen/qwen2.5-coder-14b}

install_hook() {
  cat > "$HOOK_FILE" <<EOF
#!/bin/bash
# Git hook: prepare-commit-msg
# Auto-generated by $SCRIPT_NAME

# Do not override merge, squash, or tag messages
if [[ "\$2" == "merge" || "\$2" == "squash" || "\$2" == "tag" ]]; then
  exit 0
fi

# Call this script with appropriate args
$(realpath "$0") --hook "\$1"
EOF

  chmod +x "$HOOK_FILE"
  echo "✅ Git hook 'prepare-commit-msg' installed at $HOOK_FILE"
  exit 0
}

# Handle --install flag
if [[ "$1" == "--install" ]]; then
  install_hook
fi

# If run as hook, $1 is the path to the commit message file
if [[ "$1" == "--hook" && -n "$2" ]]; then
  COMMIT_MSG_FILE="$2"
else
  COMMIT_MSG_FILE=""
fi

# Check dependencies
for dep in git curl jq; do
  if ! command -v "$dep" &> /dev/null; then
    echo "❌ $dep is not installed" >&2
    exit 1
  fi
done

# Check staged changes
DIFF_OUTPUT=$(git diff --cached)
DIFF_SIZE=${#DIFF_OUTPUT}

if [ "$DIFF_SIZE" -eq 0 ]; then
  echo "❌ No staged changes. Run 'git add' first." >&2
  exit 1
fi

SYSTEM="You're a Git commit message generator."
PROMPT="
Generate a short, one-line Git commit message from the diff below.

Use conventional commit format (feat, fix, refactor, chore, build, test, docs, style, perf).
Use imperative verbs (e.g. add, fix, refactor, update).
End with a fitting emoji.

Only output the message. No extra text.

Return format: <type>: <action> <subject> <emoji>
Example: feat: add search bar to header ✨

Diff:

$DIFF_OUTPUT
"

RESPONSE=$(
  jq -nc --arg model "$MODEL" --arg prompt "$PROMPT" --arg system "$SYSTEM" \
    '{
      model: $model,
      messages: [
        { role: "system", content: $system },
        { role: "user", content: $prompt }
      ],
      stream: false
    }' |
  curl -s http://localhost:1234/v1/chat/completions \
    -H "Content-Type: application/json" \
    -d @- \
    --silent --show-error --fail
)

if [[ "$RESPONSE" == *"error"* ]]; then
  echo "❌ Request failed: $RESPONSE" >&2
  exit 1
fi

COMMIT_MESSAGE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')

if [ -z "$COMMIT_MESSAGE" ]; then
  COMMIT_MESSAGE=$(echo "$RESPONSE" | grep -o '"content":"[^"]*' | cut -d '"' -f4)
fi

if [ -z "$COMMIT_MESSAGE" ]; then
  echo "❌ No commit message generated. Please check the model response." >&2
  exit 1
fi

# If used from hook, write to commit message file
if [ -n "$COMMIT_MSG_FILE" ]; then
  echo "$COMMIT_MESSAGE" > "$COMMIT_MSG_FILE"
else
  echo "$COMMIT_MESSAGE"
fi
