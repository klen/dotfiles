#!/bin/bash

# Variables
# ---------
MODEL=${MODEL:-qwen/qwen2.5-coder-14b}

SYSTEM="You're a Git commit message generator."
PROMPT="
Generate a short, one-line Git commit message from the diff below.

Use conventional commit format (feat, fix, refactor, chore, build, test, docs, style, perf).
Use imperative verbs (e.g. add, fix, refactor, update).
End with a fitting emoji.

Only output the message. No extra text.

Return format: <type>: <action> <subject> <emoji>
Example: feat: add search bar to header ✨

Diff:"

HOOK_FILE=".git/hooks/prepare-commit-msg"
HUSKY_HOOK_FILE=".husky/prepare-commit-msg"
SCRIPT_NAME=$(basename "$0")

# Functions
# --------
show_help() {
  cat <<EOF
Usage: $0 [--install | --husky | --hook <commit-msg-file> | --help]

Options:
  --install              Install this script as a Git prepare-commit-msg hook
  --husky                Install this script as a Husky hook
  --hook <file>          Internal use: invoked by Git with path to commit message file
  --help, -h             Show this help message

Description:
  When invoked normally (no args), the script analyzes staged changes
  and generates a Git commit message using an LLM running locally.

Examples:
  $0                         # Generate a commit message and print it
  $0 --install               # Install as Git hook
  $0 --husky                 # Install as Husky hook
  $0 --hook .git/COMMIT_EDITMSG  # Called by Git automatically
EOF
  exit 0}
}

install_hook() {
  cat > "$HOOK_FILE" <<EOF
#!/bin/bash
# Auto-generated by $SCRIPT_NAME

# Do not override merge, squash, or tag messages
case "\$2" in
  merge|squash|tag) exit 0 ;;
esac

# Call this script with appropriate args
$(realpath "$0") --hook "\$1"
EOF

  chmod +x "$HOOK_FILE"
  echo "✅ Git hook 'prepare-commit-msg' installed at $HOOK_FILE"
  exit 0
}

install_husky_hook() {
  mkdir -p "$(dirname "$HUSKY_HOOK_FILE")"

  cat > "$HUSKY_HOOK_FILE" <<EOF
#!/bin/sh
case "\$2" in
  merge|squash|tag) exit 0 ;;
esac

$(realpath "$0") --hook "\$1"
EOF

  chmod +x "$HUSKY_HOOK_FILE"
  echo "✅ Husky hook installed at $HUSKY_HOOK_FILE"
  exit 0
}

# Handle flags
# ------------
case "$1" in
  --help|-h)
    show_help
    ;;
  --install)
    install_hook
    ;;
  --husky)
    install_husky_hook
    ;;
  --hook)
    if [ -z "$2" ]; then
      echo "❌ --hook requires a commit message file path."
      exit 1
    fi
    COMMIT_MSG_FILE="$2"
    ;;
  "")
    COMMIT_MSG_FILE=""
    ;;
  *)
    echo "❌ Unknown option: $1"
    echo "Use --help for usage information"
    exit 1
    ;;
esac

# Check dependencies
# ------------------
for dep in git curl jq; do
  if ! command -v "$dep" &> /dev/null; then
    echo "❌ $dep is not installed" >&2
    exit 1
  fi
done

# Check if we're in a Git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "❌ Not a Git repository." >&2
  exit 1
fi

# Check staged changes
# --------------------
DIFF_OUTPUT=$(git diff --cached)
DIFF_SIZE=${#DIFF_OUTPUT}

if [ "$DIFF_SIZE" -eq 0 ]; then
  echo "❌ No staged changes. Run 'git add' first." >&2
  exit 1
fi

PROMPT="$PROMPT

$DIFF_OUTPUT"

RESPONSE=$(
  jq -nc --arg model "$MODEL" --arg prompt "$PROMPT" --arg system "$SYSTEM" \
    '{
      model: $model,
      messages: [
        { role: "system", content: $system },
        { role: "user", content: $prompt }
      ],
      stream: false
    }' |
  curl -s http://localhost:1234/v1/chat/completions \
    -H "Content-Type: application/json" \
    -d @- \
    --silent --show-error --fail
)

if [[ "$RESPONSE" == *"error"* ]]; then
  echo "❌ Request failed: $RESPONSE" >&2
  exit 1
fi

COMMIT_MESSAGE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')

# Fallback if jq fails
if [ -z "$COMMIT_MESSAGE" ]; then
  COMMIT_MESSAGE=$(echo "$RESPONSE" | grep -o '"content":"[^"]*' | cut -d '"' -f4)
fi

if [ -z "$COMMIT_MESSAGE" ]; then
  echo "❌ No commit message generated. Please check the model response." >&2
  exit 1
fi

 # Clean up ``` markdown blocks if present
COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | sed '/^```/d')

# Output
if [ -n "$COMMIT_MSG_FILE" ]; then
  echo "$COMMIT_MESSAGE" > "$COMMIT_MSG_FILE"
else
  echo "$COMMIT_MESSAGE"
fi
