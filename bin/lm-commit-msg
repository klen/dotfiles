#!/bin/bash

# Variables
# ---------
LLM=${LLM:-qwen/qwen2.5-coder-14b}

# New variable for context limit in characters
CONTEXT_LIMIT=${CONTEXT_LIMIT:-8192} # Default to 8192 characters

SYSTEM="You're a Git commit message generator."
PROMPT="
Generate a Git commit message from the diff below.

Use conventional commit format (feat, fix, refactor, chore, build, test, docs, style, perf).
The first line should be a short, one-line message.
Use imperative verbs (e.g. add, fix, refactor, update).
End the first line with a fitting emoji.

After the first line, provide a more detailed explanation of the changes. This can be multiple lines if necessary.

Only output the message. No extra text.

Return format:
<type>: <action> <subject> <emoji>

<Detailed explanation of changes, possibly multiline.>

Example:
feat: add search bar to header ✨

This commit introduces a new search bar component in the header section of the application. It allows users to quickly search for content across the site. The search functionality is integrated with the existing backend API.

Diff:"

HOOK_FILE=".git/hooks/prepare-commit-msg"
HUSKY_HOOK_FILE=".husky/prepare-commit-msg"
SCRIPT_NAME=$(basename "$0")

# Functions
# --------
show_help() {
  cat <<EOF
Usage: $0 [--install | --husky | --hook <commit-msg-file> | --help]

Options:
  --install               Install this script as a Git prepare-commit-msg hook
  --husky                 Install this script as a Husky hook
  --hook <file>           Internal use: invoked by Git with path to commit message file
  --help, -h              Show this help message

Description:
  When invoked normally (no args), the script analyzes staged changes
  and generates a Git commit message using an LLM running locally.

Examples:
  $0                      # Generate a commit message and print it
  $0 --install            # Install as Git hook
  $0 --husky              # Install as Husky hook
  $0 --hook .git/COMMIT_EDITMSG  # Called by Git automatically
EOF
  exit 0
}

install_hook() {
  cat >"$HOOK_FILE" <<EOF
#!/bin/bash
# Auto-generated by $SCRIPT_NAME

# Do not override merge, squash, or tag messages
case "\$2" in
  amend|merge|squash|tag) exit 0 ;;
esac

# Call this script with appropriate args
$(realpath "$0") --hook "\$1" || true
EOF

  chmod +x "$HOOK_FILE"
  echo "✅ Git hook 'prepare-commit-msg' installed at $HOOK_FILE"
  exit 0
}

install_husky_hook() {
  mkdir -p "$(dirname "$HUSKY_HOOK_FILE")"

  cat >"$HUSKY_HOOK_FILE" <<EOF
#!/bin/sh
case "\$2" in
  amend|merge|squash|tag) exit 0 ;;
esac

if ! command -v lm-commit-msg > /dev/null 2>&1; then
  echo "⚠️ lm-commit-msg not found in PATH, skipping hook"
  exit 0
fi

lm-commit-msg --hook "\$1" || true
EOF

  chmod +x "$HUSKY_HOOK_FILE"
  echo "✅ Husky hook installed at $HUSKY_HOOK_FILE"
  exit 0
}

# Handle flags
# ------------
case "$1" in
--help | -h)
  show_help
  ;;
--install)
  install_hook
  ;;
--husky)
  install_husky_hook
  ;;
--hook)
  if [ -z "$2" ]; then
    echo "❌ --hook requires a commit message file path."
    exit 1
  fi
  COMMIT_MSG_FILE="$2"
  ;;
"")
  COMMIT_MSG_FILE=""
  ;;
*)
  echo "❌ Unknown option: $1"
  echo "Use --help for usage information"
  exit 1
  ;;
esac

# Check dependencies
# ------------------
for dep in git curl jq; do
  if ! command -v "$dep" &>/dev/null; then
    echo "❌ $dep is not installed" >&2
    exit 1
  fi
done

# Check if we're in a Git repo
if ! git rev-parse --git-dir >/dev/null 2>&1; then
  echo "❌ Not a Git repository." >&2
  exit 1
fi

# Check staged changes
# --------------------
DIFF_OUTPUT=$(git diff --cached)
DIFF_SIZE=${#DIFF_OUTPUT}

if [ "$DIFF_SIZE" -eq 0 ]; then
  echo "❌ No staged changes. Run 'git add' first." >&2
  exit 1
fi

# Truncate diff if it exceeds CONTEXT_LIMIT
if [ "$DIFF_SIZE" -gt "$CONTEXT_LIMIT" ]; then
  echo "✂️ Diff truncated from $DIFF_SIZE to $CONTEXT_LIMIT characters due to CONTEXT_LIMIT." >&2
  DIFF_OUTPUT=$(echo "$DIFF_OUTPUT" | head -c "$CONTEXT_LIMIT")
fi

PROMPT="$PROMPT

$DIFF_OUTPUT"

# Make the curl request and capture the raw JSON response
RESPONSE_JSON=$(
  jq -nc --arg model "$LLM" --arg prompt "$PROMPT" --arg system "$SYSTEM" \
    '{
      model: $model,
      messages: [
        { role: "system", content: $system },
        { role: "user", content: $prompt }
      ],
      stream: false
    }' |
    curl -s http://localhost:1234/v1/chat/completions \
      -H "Content-Type: application/json" \
      -d @- \
      --silent --show-error --fail
)

# Check if curl command itself failed (e.g., connection refused, bad URL)
if [ $? -ne 0 ]; then
  echo "❌ curl command failed to connect to LLM API. Make sure your LLM server is running at http://localhost:1234." >&2
  exit 1
fi

# Check if the response is valid JSON and contains a top-level "error" key
if echo "$RESPONSE_JSON" | jq -e 'has("error")' >/dev/null 2>&1; then
  ERROR_MESSAGE=$(echo "$RESPONSE_JSON" | jq -r '.error.message // .error // "Unknown error"')
  echo "❌ LLM API responded with an error: $ERROR_MESSAGE" >&2
  exit 1
# Check if the response is malformed JSON
elif ! echo "$RESPONSE_JSON" | jq -e '.' >/dev/null 2>&1; then
  echo "❌ LLM API returned malformed JSON response: $RESPONSE_JSON" >&2
  exit 1
fi

# Extract the commit message content using jq
COMMIT_MESSAGE=$(echo "$RESPONSE_JSON" | jq -r '.choices[0].message.content')

# Fallback/validation: Ensure the extracted message is not empty or "null" literal
if [ -z "$COMMIT_MESSAGE" ] || [ "$COMMIT_MESSAGE" = "null" ]; then
  echo "❌ No commit message generated or the content field was empty/null. Please check the LLM's response structure." >&2
  exit 1
fi

# Clean up ``` markdown blocks if present
COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | sed '/^```bash\|^```text\|^```markdown\|^```/d')

# Output
if [ -n "$COMMIT_MSG_FILE" ]; then
  echo "$COMMIT_MESSAGE" >"$COMMIT_MSG_FILE"
else
  echo "$COMMIT_MESSAGE"
fi
